>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/auth.strategy.js
const config = require("./config");
const passport = require("passport");
const passportJWT = require("passport-jwt");
const User = require("./model/user");
const LocalStrategy = require("passport-local").Strategy;
const JWTStrategy = passportJWT.Strategy;
const ExtractJWT = passportJWT.ExtractJwt;

const localStrategyOpts = {
  usernameField: "email",
  passwordField: "password",
};

const localStrategyCallback = async (username, password, callback) => {
  console.log(`Attempting to authenticate user: ${username}`);
  const user = await User.findOne({
    email: username,
    enabled: true,
  }).populate("roles");
  if (user) {
    console.log(`User found: ${username}`);
    const isValid = await user.isPasswordValid(password);
    console.log(`Password valid: ${isValid}`);
    if (isValid) {
      return callback(null, user);
    }
  }
  console.log(`Authentication failed for user: ${username}`);
  return callback(null, false);
};

passport.use(
  "login",
  new LocalStrategy(localStrategyOpts, localStrategyCallback)
);

const jwtStrategyOpts = {
  jwtFromRequest: ExtractJWT.fromAuthHeaderAsBearerToken(),
  secretOrKey: config.jwt.secret,
};

const jwtStrategyCallback = async (jwtPayload, callback) => {
  console.log(`Verifying JWT for user ID: ${jwtPayload.id}`);
  const user = await User.findOne({ _id: jwtPayload.id }).populate("roles");
  if (user) {
    console.log(`JWT verified for user: ${user.email}`);
    return callback(null, user);
  }
  console.log(`JWT verification failed for user ID: ${jwtPayload.id}`);
  return callback(null, false);
};

passport.use("jwt", new JWTStrategy(jwtStrategyOpts, jwtStrategyCallback));




>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/bootstrap/database.js
const {
  User,
  Role,
  Course,
  Classroom,
  Document,
  Exam,
  ExamStudent,
} = require("../model");
const config = require("../config");
const { UserType, Permission, QuestionType } = require("../enumerator");

const DAY_AS_TIMESTAMP = 24 * 60 * 60 * 1000;

const SAMPLE_EXAM_URL =
  "https://s3.sa-east-1.amazonaws.com/storage.eucorrijo.com/exams/5d8f051d-8188-4ca2-ab00-f1e20f72f5ff.pdf";

async function initializeDev() {
  console.log("Initializing development data");
  const coordenadorPerfil = await Role.create({
    name: "coordenador",
    permissions: Object.values(Permission).map((o) => o.key),
  });

  await User.create({
    email: "nunes.lfa@gmail.com",
    password: "abc123",
    type: UserType.SUPERUSER,
  });

  await User.create({
    email: "romulo.nf@gmail.com",
    password: "abc123",
    type: UserType.SUPERUSER,
  });

  await User.create({
    email: "jon@doe.com",
    name: "Jon Doe",
    password: "abc123",
    contactNumber: "(45) 43534-5345",
    type: UserType.STAFF,
    roles: [coordenadorPerfil],
  });

  const studentA = await User.create({
    email: "studenta@gmail.com",
    name: "Student A",
    password: "abc123",
    type: UserType.STUDENT,
  });
  const studentB = await User.create({
    email: "studentb@gmail.com",
    name: "Student B",
    password: "abc123",
    type: UserType.STUDENT,
  });
  const studentC = await User.create({
    email: "studentc@gmail.com",
    name: "Student C",
    password: "abc123",
    type: UserType.STUDENT,
  });

  const teacherA = await User.create({
    email: "teachera@gmail.com",
    name: "Teacher A",
    password: "abcd1234",
    type: UserType.TEACHER,
  });
  const teacherB = await User.create({
    email: "teacherb@gmail.com",
    name: "Teacher B",
    password: "abcd1234",
    type: UserType.TEACHER,
  });
  const teacherC = await User.create({
    email: "teacherc@gmail.com",
    name: "Teacher C",
    password: "abcd1234",
    type: UserType.TEACHER,
  });

  const classroomA = await Classroom.create({
    name: "A",
    year: 2021,
    level: "1",
    students: [studentA, studentB],
  });

  await Classroom.create({
    name: "B",
    year: 2021,
    level: "1",
    students: [studentA, studentC],
  });

  await Classroom.create({
    name: "C",
    year: 2021,
    level: "1",
    students: [studentB, studentC],
  });

  ["A", "B", "C"].forEach(async (name) => {
    [2018, 2019, 2020].forEach(async (year) => {
      ["1", "2", "3"].forEach(async (level) => {
        await Classroom.create({ name, year, level });
      });
    });
  });

  const courseA = await Course.create({ name: "Portugues" });
  const courseB = await Course.create({ name: "Matematica" });
  const formatDate = (date) => new Date(date).toISOString();

  await Exam.create({
    uuid: "dd4e5003-0041-4731-9beb-790c7573beaa",
    name: "Prova de Matematica",
    startAt: formatDate(Date.now() - DAY_AS_TIMESTAMP),
    endAt: formatDate(Date.now() + 1000), // 30 seconds
    documentUrl: SAMPLE_EXAM_URL,
    questions: [],
    classrooms: [classroomA],
  });

  await Exam.create({
    name: "Prova de Fisica",
    startAt: formatDate(Date.now()),
    endAt: formatDate(Date.now() + DAY_AS_TIMESTAMP),
    documentUrl: SAMPLE_EXAM_URL,
    questions: [],
    classrooms: [classroomA],
  });

  await Exam.create({
    name: "Prova de Quimica",
    startAt: formatDate(Date.now() + DAY_AS_TIMESTAMP * 3),
    documentUrl: SAMPLE_EXAM_URL,
    questions: [],
    classrooms: [classroomA],
  });

  const exam = await Exam.create({
    uuid: "1192c2e1-c849-4a9d-a91b-b28eed94dff6",
    name: "Prova de Portugues",
    classrooms: [classroomA],
    documentUrl: SAMPLE_EXAM_URL,
    questions: [
      {
        uuid: "7c900b4e-70bb-49ca-802e-7461215dc431",
        label: "Portugues 1",
        type: QuestionType.A,
        answer: "C",
        course: courseA.uuid,
      },
      {
        uuid: "0693b959-b030-4f5c-b030-e8798ecf4c5c",
        label: "Portugues 2",
        type: QuestionType.A,
        answer: "E",
        course: courseA.uuid,
      },
      {
        uuid: "dc8b399c-a0c0-4e4f-8731-0cd83498e930",
        label: "Matematica 1",
        type: QuestionType.A,
        answer: "C",
        course: courseB.uuid,
      },
      {
        uuid: "bde9f55f-869c-44ab-9358-9b1f0a4cd2ac",
        label: "Matematica 2",
        type: QuestionType.A,
        answer: "E",
        course: courseB.uuid,
      },
      {
        uuid: "064f6dda-913f-43e8-88b1-241b5e6ee049",
        label: "Matematica 3",
        type: QuestionType.D,
        course: courseB.uuid,
      },
      {
        uuid: "c01b7a3a-923d-4eec-ad75-40872155c549",
        label: "Matematica 4",
        type: QuestionType.F,
        course: courseB.uuid,
      },
    ],
  });

  await ExamStudent.create({
    uuid: "f6021091-990a-4a41-82c5-f63866dd5ac5",
    exam,
    student: studentA,
    answers: {
      "7c900b4e-70bb-49ca-802e-7461215dc431": {
        value: "C",
        skipped: false,
      },
      "0693b959-b030-4f5c-b030-e8798ecf4c5c": {
        value: "C",
        skipped: false,
      },
      "dc8b399c-a0c0-4e4f-8731-0cd83498e930": {
        value: "",
        skipped: true,
      },
      "bde9f55f-869f-44ab-9358-9b1f0a4cd2ac": {
        value: "C",
        skipped: false,
      },
      "064f6dda-913f-43e8-88b1-241b5e6ee049": {
        value: "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
        skipped: false,
      },
      "c01b7a3a-923d-4eec-ad75-40872155c549": {
        value:
          "https://s3.sa-east-1.amazonaws.com/storage.eucorrijo.com/cartaozinho.jpg",
        skipped: false,
      },
    },
  });

  await ExamStudent.create({
    uuid: "b71f40d4-8e6b-442f-bc92-2c4ad4d75bc2",
    exam,
    student: studentB,
    answers: {
      "7c900b4e-70bb-49ca-802e-7461215dc431": {
        value: "A",
        skipped: false,
      },
      "0693b959-b030-4f5c-b030-e8798ecf4c5c": {
        value: "B",
        skipped: false,
      },
      "dc8b399c-a0c0-4e4f-8731-0cd83498e930": {
        value: "B",
        skipped: true,
      },
      "bde9f55f-869f-44ab-9358-9b1f0a4cd2ac": {
        value: "A",
        skipped: false,
      },
      "064f6dda-913f-43e8-88b1-241b5e6ee049": {
        value: "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
        skipped: false,
      },
      "c01b7a3a-923d-4eec-ad75-40872155c549": {
        value:
          "https://s3.sa-east-1.amazonaws.com/storage.eucorrijo.com/cartaozinho.jpg",
        skipped: false,
      },
    },
  });
  console.log("Development data initialized");
}

async function initializeProd() {
  console.log("Initializing production data");
  await User.create({
    email: "professor@eucorrijo.com",
    password: "abcd1234",
    type: UserType.TEACHER,
  });

  await User.create({
    email: "silvagirao@gmail.com",
    password: config.seed.password,
    type: UserType.SUPERUSER,
  });
  console.log("Production data initialized");
}

  /* Criar documento vazio para inicializar a coleção
  await Document.create({
    name: "Documento Inicial de Produção",
    description: "Documento criado automaticamente para garantir a inicialização da coleção.",
    questions: [],
    createdBy: null, // Nenhum criador definido
    dates: {
      start: new Date(),
      teacher: new Date(),
      deadline: new Date(),
      print: new Date(),
      final: new Date(),
    },
    intervals: {
      teacherDays: 0,
      reviewDays: 0,
      printDays: 0,
      finalDays: 0,
    },
  }); */

async function initialize() {
  const userCount = await User.countDocuments();
  console.log(`User count: ${userCount}`);

  if (userCount !== 0) {
    return;
  }

  if (config.isDev) {
    initializeDev();
  } else {
    initializeProd();
  }
}

module.exports = { initialize };




>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/bootstrap/routes.js
const passport = require("passport");
const { refreshToken } = require("../middleware");

function initialize(app) {
  const authentication = passport.authenticate("jwt", { session: false });

  app.use("/", refreshToken, require("../route/public.route"));
  app.use(
    "/",
    [authentication, refreshToken],
    require("../route/protected.route")
  );

  app.use((req, res, next) => {
    return res.status(404).json({ message: "Page Not Found" });
  });

  app.use((err, req, res, next) => {
    console.error(err.stack);
    return res.status(500).json({ message: "Internal Server Error" });
  });
}

module.exports = { initialize };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/config.js
const { Header } = require("./constants");
const databaseName = process.env.DATABASE_NAME || "CHANGE_ME";
const databaseHost = process.env.DATABASE_HOST || "CHANGE_ME";
const databaseUser = process.env.DATABASE_USER || "CHANGE_ME";
const databasePass = process.env.DATABASE_PASS || "CHANGE_ME";
const databaseParams =
  process.env.DATABASE_PARAMS || "retryWrites=true&w=majority";
const databaseURL = process.env.DATABASE_URL;

const database = {
  opts: {
    useCreateIndex: true,
    useNewUrlParser: true,
    useFindAndModify: false,
    useUnifiedTopology: true,
  },
};

if (databaseURL) {
  database.url = databaseURL;
} else {
  database.url = `mongodb+srv://${databaseUser}:${databasePass}@${databaseHost}/${databaseName}?${databaseParams}`;
}

module.exports = {
  database,
  isDev: process.env.DEV_MODE || false,
  exam: {
    comingSoonMaxDays: process.env.COMING_SOON_MAX_DAYS || 7,
  },
  seed: {
    password: process.env.SEED_PASSWORD || "",
  },
  s3: {
    prefix: process.env.S3_PREFIX || "",
    bucket: process.env.S3_BUCKET || "storage.eucorrijo.com",
    credentials: {
      accessKey: process.env.S3_ACCESS_KEY || "",
      secretKey:
        process.env.S3_SECRET_KEY || "",
    },
  },
  jwt: {
    refresh_header: Header.REFRESH_TOKEN,
    secret: process.env.JWT_SECRET || "CHANGE_ME",
  },
  timezone: process.env.TIMEZONE || "America/Sao_Paulo",
  server_port: process.env.PORT || 4000,
};



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/constants.js
class Header {
  static REFRESH_TOKEN = "x-refresh-token";
}

module.exports = { Header };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/ecosystem.config.js
module.exports = {
  apps: [
    {
      script: "index.js",
      watch: ".",
      instances: "max",
      env: {
        NODE_ENV: "development",
      },
      env_production: {
        NODE_ENV: "production",
      },
    },
  ],
};



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/enumerator.js
const Permission = {
  CREATE_ROLE: { key: "create-role", label: "Criar", context: "Perfil" },
  READ_ROLE: { key: "read-role", label: "Listar", context: "Perfil" },
  UPDATE_ROLE: { key: "update-role", label: "Editar", context: "Perfil" },
  DELETE_ROLE: { key: "delete-role", label: "Remover", context: "Perfil" },

  CREATE_COURSE: {
    key: "create-course",
    label: "Criar",
    context: "Disciplina",
  },
  READ_COURSE: { key: "read-course", label: "Listar", context: "Disciplina" },
  UPDATE_COURSE: {
    key: "update-course",
    label: "Editar",
    context: "Disciplina",
  },
  DELETE_COURSE: {
    key: "delete-course",
    label: "Remover",
    context: "Disciplina",
  },

  CREATE_CLASSROOM: {
    key: "create-classroom",
    label: "Criar",
    context: "Turma",
  },
  READ_CLASSROOM: { key: "read-classroom", label: "Listar", context: "Turma" },
  UPDATE_CLASSROOM: {
    key: "update-classroom",
    label: "Editar",
    context: "Turma",
  },
  DELETE_CLASSROOM: {
    key: "delete-classroom",
    label: "Remover",
    context: "Turma",
  },

  CREATE_STUDENT: { key: "create-student", label: "Criar", context: "Aluno" },
  READ_STUDENT: { key: "read-student", label: "Listar", context: "Aluno" },
  UPDATE_STUDENT: { key: "update-student", label: "Editar", context: "Aluno" },
  DELETE_STUDENT: { key: "delete-student", label: "Remover", context: "Aluno" },

  CREATE_TEACHER: { key: "create-teacher", label: "Criar", context: "Professor" },
  READ_TEACHER: { key: "read-teacher", label: "Listar", context: "Professor" },
  UPDATE_TEACHER: { key: "update-teacher", label: "Editar", context: "Professor" },
  DELETE_TEACHER: { key: "delete-teacher", label: "Remover", context: "Professor" },

  CREATE_STAFF: { key: "create-staff", label: "Criar", context: "Colaborador" },
  READ_STAFF: { key: "read-staff", label: "Listar", context: "Colaborador" },
  UPDATE_STAFF: {
    key: "update-staff",
    label: "Editar",
    context: "Colaborador",
  },
  DELETE_STAFF: {
    key: "delete-staff",
    label: "Remover",
    context: "Colaborador",
  },

  CREATE_EXAM: { key: "create-exam", label: "Criar", context: "Exame" },
  READ_EXAM: { key: "read-exam", label: "Listar", context: "Exame" },
  UPDATE_EXAM: { key: "update-exam", label: "Editar", context: "Exame" },
  DELETE_EXAM: { key: "delete-exam", label: "Remover", context: "Exame" },
  EXPORT_EXAM: { key: "export-exam", label: "Exportar", context: "Exame" },
  
  CREATE_DOCUMENT: { key: "create-document", label: "Criar", context: "Document" },
  READ_DOCUMENT: { key: "read-document", label: "Listar", context: "Document" },
  UPDATE_DOCUMENT: { key: "update-document", label: "Editar", context: "Document" },
  DELETE_DOCUMENT: { key: "delete-document", label: "Remover", context: "Document" },
  EXPORT_DOCUMENT: { key: "export-document", label: "Exportar", context: "Document" },
};

const UserType = {
  STAFF: "staff",
  TEACHER: "teacher",
  STUDENT: "student",
  SUPERUSER: "superuser",
};

const StorageFolder = {
  EXAMS: "exams",
};

const QuestionType = {
  A: "A", // c,e
  B: "B", // 3 digitos
  C: "C", // a,b,c,d
  D: "D", // texto livre
  ENEM: "ENEM", // a,b,c,d,e
  F: "F", // foto
};

const ExamStudentStatus = {
  PROGRESS: "progress",
  SUBMITTED: "submitted",
};

const GradeType = {
  SCORE: "SCORE",
  PAS: "PAS",
};

module.exports = {
  Permission,
  UserType,
  StorageFolder,
  QuestionType,
  ExamStudentStatus,
  GradeType,
};



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/index.js
require("dotenv").config();
require("./auth.strategy");

const { Header } = require("./constants");
const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");
const config = require("./config");

const app = express();
app.use(cors({ exposedHeaders: Header.REFRESH_TOKEN }));
app.use(require("helmet")());
app.use(require("compression")());
app.use(require("body-parser").json({ limit: "5mb" }));

console.log("Connecting to MongoDB...");
mongoose.connect(config.database.url, config.database.opts);

const databaseConnection = mongoose.connection;

databaseConnection.on("error", (error) => {
  console.log(`Error connecting to database: ${error}`);
});

databaseConnection.on("open", () => {
  console.log("Connected to MongoDB. Starting server...");
  app.listen(config.server_port, () => {
    console.log(`Server running on port ${config.server_port}`);
    require("./bootstrap/database").initialize();
    require("./bootstrap/routes").initialize(app);
  });
});

// require("./util/grade.util.test");



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/middleware.js
const config = require("./config");
const { UserType } = require("./enumerator");

const hasPermission = (permission) => {
  return (req, res, next) => {
    const user = req.user;
    if (user.type === UserType.SUPERUSER || user.hasPermission(permission)) {
      return next();
    }
    return res.status(403).json({ message: "Not authorized" });
  };
};

const isUserType = (type) => (req, res, next) => {
  if (req.user.type === type) {
    return next();
  }
  return res.status(403).json({ message: "Not authorized" });
};

const isStaff = isUserType(UserType.STAFF);
const isStudent = isUserType(UserType.STUDENT);
const isTeacher = isUserType(UserType.TEACHER);
const isSuperuser = isUserType(UserType.SUPERUSER);

const refreshToken = (req, res, next) => {
  if (req.user) {
    res.setHeader(config.jwt.refresh_header, req.user.getJwtToken());
  }
  next();
};

module.exports = {
  hasPermission,
  isStaff,
  isStudent,
  isTeacher,
  isSuperuser,
  refreshToken,
};



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/base.js
const { v4: uuidv4 } = require("uuid");

const BaseModel = {
  uuid: {
    type: String,
    required: true,
    immutable: true,
    default: () => uuidv4(),
  },
  enabled: {
    type: Boolean,
    default: true,
  },
};

const BaseSchemaOptions = {
  timestamps: true,
  collation: { locale: "en" },
};

module.exports = { BaseModel, BaseSchemaOptions };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/classroom.js
const mongoose = require("mongoose");
const { BaseModel, BaseSchemaOptions } = require("./base");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  name: {
    type: String,
    trim: true,
    required: true,
  },
  year: {
    type: Number,
    required: true,
  },
  level: {
    type: String,
    required: true,
  },
  shift: {
    type: String,
  },
  students: [{ type: Schema.Types.ObjectId, ref: "User" }],
};

const ClassroomSchema = new Schema(schemaObj, BaseSchemaOptions);

ClassroomSchema.index({ name: 1, year: 1, level: 1 }, { unique: true });

module.exports = mongoose.model("Classroom", ClassroomSchema);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/course.js
const mongoose = require("mongoose");
const { BaseModel, BaseSchemaOptions } = require("./base");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  name: {
    type: String,
    unique: true,
    trim: true,
    required: true,
  },
};

const CourseSchema = new Schema(schemaObj, BaseSchemaOptions);

module.exports = mongoose.model("Course", CourseSchema);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/document.js
const mongoose = require("mongoose");
const { BaseModel, BaseSchemaOptions } = require("./base");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  name: { type: String, required: true },
  description: { type: String },
  questions: [
    {
      uuid: { type: String, required: true },
      teacher: { type: Schema.Types.ObjectId, ref: "User", required: true },
      course: { type: Schema.Types.ObjectId, ref: "Course", required: true },
      state: {
        type: String,
        enum: ["pending", "submitted", "approved", "rejected"],
        default: "pending",
      },
      questionFileUrl: { type: String },
      comments: { type: String },
    },
  ],
  createdBy: { type: Schema.Types.ObjectId, ref: "User", required: true },
  dates: {
    start: { type: Date, required: true },
    teacher: { type: Date, required: true },
    print: { type: Date, required: true },
    final: { type: Date, required: true },
  },
  state: {
    type: String,
    enum: ["draft", "in_progress", "completed"],
    default: "draft",
  },
};

const DocumentSchema = new Schema(schemaObj, BaseSchemaOptions);

module.exports = mongoose.model("Document", DocumentSchema);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/exam.js
const mongoose = require("mongoose");
const { ExamStudentStatus, GradeType } = require("../enumerator");
const { BaseModel, BaseSchemaOptions } = require("./base");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  name: { type: String, trim: true, required: true },
  startAt: { type: Date },
  endAt: { type: Date },
  durationExam: { type: String },
  instructions: { type: String },
  documentUrl: { type: String },
  questions: [{ type: Object }],
  gradeStrategy: {
    type: String,
    required: true,
    default: GradeType.SCORE,
    enum: Object.values(GradeType),
  },
  gradeOptions: { type: Object },
  classrooms: [{ type: Schema.Types.ObjectId, ref: "Classroom" }],
};

const ExamSchema = new Schema(schemaObj, BaseSchemaOptions);

ExamSchema.virtual("examsInProgress", {
  ref: "ExamStudent",
  localField: "_id",
  foreignField: "exam",
  match: {
    enabled: true,
    status: ExamStudentStatus.PROGRESS,
  },
});

ExamSchema.virtual("examsSubmitted", {
  ref: "ExamStudent",
  localField: "_id",
  foreignField: "exam",
  match: {
    enabled: true,
    status: ExamStudentStatus.SUBMITTED,
  },
});

module.exports = mongoose.model("Exam", ExamSchema);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/exam.student.js
const mongoose = require("mongoose");
const { BaseModel, BaseSchemaOptions } = require("./base");
const { ExamStudentStatus } = require("../enumerator");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  answers: { type: Object, default: {} },
  grade: { type: Object },
  status: {
    type: String,
    required: true,
    default: ExamStudentStatus.PROGRESS,
    enum: Object.values(ExamStudentStatus),
  },
  submittedAt: { type: Date },
  exam: { type: Schema.Types.ObjectId, ref: "Exam" },
  student: { type: Schema.Types.ObjectId, ref: "User" },
};

const ExamStudentSchema = new Schema(schemaObj, BaseSchemaOptions);

ExamStudentSchema.index({ exam: 1, student: 1 }, { unique: true });

module.exports = mongoose.model("ExamStudent", ExamStudentSchema);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/role.js
const mongoose = require("mongoose");
const { BaseModel, BaseSchemaOptions } = require("./base");
const { Permission } = require("../enumerator");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  name: {
    type: String,
    unique: true,
    trim: true,
    required: true,
  },
  permissions: [
    {
      type: String,
      enum: Object.values(Permission).map((o) => o.key),
    },
  ],
};

const RoleSchema = new Schema(schemaObj, BaseSchemaOptions);

module.exports = mongoose.model("Role", RoleSchema);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model/user.js
const { encryptPassword, comparePassword } = require("../util/password.util");
const config = require("../config");
const jwt = require("jsonwebtoken");
const { UserType, Permission } = require("../enumerator");
const { BaseModel, BaseSchemaOptions } = require("./base");
const mongoose = require("mongoose");

const Schema = mongoose.Schema;

const schemaObj = {
  ...BaseModel,
  email: {
    type: String,
    unique: true,
    trim: true,
    required: true,
  },
  password: {
    type: String,
    trim: true,
    required: true,
  },
  type: {
    type: String,
    required: true,
    enum: Object.values(UserType),
  },
  name: {
    type: String,
  },
  cpf: {
    type: String,
    minLength: 11,
    maxLength: 11,
  },
  contactNumber: {
    type: String,
  },
  parentName: {
    type: String,
  },
  parentContactNumber: {
    type: String,
  },
  roles: [{ type: Schema.Types.ObjectId, ref: "Role" }],
};

const UserSchema = new Schema(schemaObj, BaseSchemaOptions);

UserSchema.virtual("classrooms", {
  ref: "Classroom",
  localField: "_id",
  foreignField: "students",
  match: { enabled: true },
  options: { sort: { name: 1 } },
});

UserSchema.pre("save", async function (next) {
  console.log(`Hashing password for user: ${this.email}`);
  this.password = await encryptPassword(this.password);
  next();
});

UserSchema.methods.isPasswordValid = async function isPasswordValid(password) {
  console.log(`Comparing passwords for user: ${this.email}`);
  return await comparePassword(password, this.password);
};

UserSchema.methods.hasPermission = function hasPermission(permission) {
  const permissionFilter = (entry) => entry === permission;
  const roleFilter = (role) => role.permissions.some(permissionFilter);
  return this.roles.filter(roleFilter).length;
};

UserSchema.methods.getPermissions = function getPermissions() {
  if (this.type === UserType.SUPERUSER) {
    return Object.values(Permission).map((o) => o.key);
  }
  const roleReducer = (accumulator, role) => {
    role.permissions.forEach((entry) => {
      if (!accumulator.includes(entry)) {
        accumulator.push(entry);
      }
    });
    return accumulator;
  };
  return this.roles.reduce(roleReducer, []);
};

UserSchema.methods.getMissingPermissions = function getMissingPermissions() {
  const permissions = this.getPermissions();
  return Object.values(Permission)
    .map((o) => o.key)
    .filter((o) => !permissions.includes(o));
};

UserSchema.methods.getJwtToken = function getJwtToken() {
  const { id, email, name, type } = this;
  const permissions = this.getPermissions();
  return jwt.sign({ id, email, name, type, permissions }, config.jwt.secret);
};

module.exports = mongoose.model("User", UserSchema);




>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/model.js
const Classroom = require("./model/classroom");
const Course = require("./model/course");
const Exam = require("./model/exam");
const ExamStudent = require("./model/exam.student");
const Role = require("./model/role");
const User = require("./model/user");
const Document = require("./model/document");

module.exports = { Classroom, Course, Exam, ExamStudent, Role, User, Document };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/README.md
# Pre-requisitos

1. [Node](https://nodejs.org/en/download/)
2. [MongoDB](https://www.mongodb.com/try/download/community)
3. [MongoDB Compass](https://www.mongodb.com/products/compass)
4. Yarn ou NPM

# Baixando as dependências

Execute o seguinte comando na raiz do projeto se estiver utilizando **Yarn**:

```
yarn install
```

# DOTENV

A aplicação faz uso do pacote [dotenv](https://www.npmjs.com/package/dotenv) para carregar configurações a partir de um arquivo `.env`

Cria o arquivo `.env` na raiz do projeto com o seguinte conteúdo:

```
DATABASE_URL=mongodb://localhost:27017/aplicaprovas
```

# Como subir a aplicação

Para inicializar a aplicação localmente execute o script `dev`.


>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/account.route.js
const express = require("express");
const router = express.Router();

router.post("/password", async (req, res) => {
  try {
    const { user } = req;
    const { password } = req.body;

    if (!password) {
      throw new Error("Senha é obrigatória");
    }

    if (password.length < 6) {
      throw new Error("Senha deve possuir no mínimo 6 caracteres");
    }

    user.password = password;

    await user.save();

    return res.sendStatus(204);
  } catch (ex) {
    const { message = "Erro ao atualizar a senha" } = ex;
    return res.status(400).json({ message });
  }
});

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/classrooms.route.js
const express = require("express");
const router = express.Router();
const { User, Classroom } = require("../../model");
const { Permission, UserType } = require("../../enumerator");
const { hasPermission } = require("../../middleware");

router.get(
  "",
  hasPermission(Permission.READ_CLASSROOM.key),
  async (req, res) => {
    try {
      const classrooms = await Classroom.find()
        .select("uuid name year level shift enabled")
        .populate({ path: "students", select: "-_id uuid name email" })
        .sort({ name: 1, level: 1, year: 1 })
        .lean();
      return res.json(classrooms);
    } catch (ex) {
      const { message = "Erro ao recuperar turmas" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.get(
  "/:uuid",
  hasPermission(Permission.READ_CLASSROOM.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const classroom = await Classroom.findOne({ uuid })
        .lean()
        .populate({ path: "students", select: "uuid email name" });

      if (!classroom) {
        throw new Error("Erro ao recuperar turma");
      }

      return res.json(classroom);
    } catch (ex) {
      const { message = "Erro ao recuperar turma" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.post(
  "",
  hasPermission(Permission.CREATE_CLASSROOM.key),
  async (req, res) => {
    try {
      const { name, level, year } = req.body;

      const students = await User.find({
        type: UserType.STUDENT,
        uuid: req.body.students,
      });

      const classroom = await Classroom.create({ name, level, year, students });

      if (!classroom) {
        throw new Error("Erro ao criar turma");
      }

      const { uuid } = classroom;
      return res.json({ uuid });
    } catch (ex) {
      const { message = "Erro ao criar turma" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.put(
  "/:uuid",
  hasPermission(Permission.CREATE_CLASSROOM.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const students = await User.find({
        type: UserType.STUDENT,
        uuid: req.body.students,
      });

      const updateQuery = { ...req.body, students };

      const classroom = await Classroom.findOneAndUpdate({ uuid }, updateQuery);

      if (!classroom) {
        throw new Error("Erro ao atualizar turma");
      }

      return res.json({ message: "Turma atualizada com sucesso" });
    } catch (ex) {
      const { message = "Erro ao atualizar turma" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_CLASSROOM.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const classroom = await Classroom.findOneAndDelete({ uuid });

      if (!classroom) {
        throw new Error("Erro ao remover turma");
      }

      return res.json({ message: "Turma removida com sucesso" });
    } catch (ex) {
      const { message = "Erro ao remover turma" } = ex;
      return res.status(400).json({ message });
    }
  }
);

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/course.route.js
const express = require("express");
const router = express.Router();
const { Course } = require("../../model");
const { Permission } = require("../../enumerator");
const { hasPermission } = require("../../middleware");

router.get("", hasPermission(Permission.READ_COURSE.key), async (req, res) => {
  try {
    const courses = await Course.find()
      .select("-_id uuid name enabled")
      .sort({ name: 1 })
      .lean();
    return res.json(courses);
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar disciplinas" });
  }
});

router.get(
  "/:uuid",
  hasPermission(Permission.READ_COURSE.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const course = await Course.findOne({ uuid }).lean();

      if (!course) {
        throw new Error();
      }

      return res.json(course);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao recuperar disciplina" });
    }
  }
);

router.post(
  "",
  hasPermission(Permission.CREATE_COURSE.key),
  async (req, res) => {
    try {
      const { name } = req.body;
      const course = await Course.create({ name });
      const { uuid } = course;
      return res.json({ uuid });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao criar disciplina" });
    }
  }
);

router.put(
  "/:uuid",
  hasPermission(Permission.UPDATE_COURSE.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const updateQuery = { ...req.body };

      const course = await Course.findOneAndUpdate({ uuid }, updateQuery);

      if (!course) {
        throw new Error();
      }

      return res.json({ message: "Disciplina atualizada com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao atualizar disciplina" });
    }
  }
);

router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_COURSE.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const course = await Course.findOneAndDelete({ uuid });

      if (!course) {
        throw new Error();
      }

      return res.json({ message: "Disciplina removida com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao remover disciplina" });
    }
  }
);

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/document.route.js
const express = require("express");
const router = express.Router();
const { Document } = require("../../model");
const { Permission } = require("../../enumerator");
const { hasPermission } = require("../../middleware");

// Listar documentos
router.get("", hasPermission(Permission.READ_DOCUMENT.key), async (req, res) => {
  console.log("Rota /document foi acessada");
  try {
    const documents = await Document.find()
      .select("uuid name description state dates")
      .populate("questions.teacher", "name email")
      .lean();
    return res.json(documents);
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar documentos" });
  }
});

// Obter detalhes de um documento
router.get(
  "/:uuid",
  hasPermission(Permission.READ_DOCUMENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const document = await Document.findOne({ uuid })
        .populate("questions.teacher", "name email")
        .populate("questions.course", "name")
        .lean();

      if (!document) {
        throw new Error("Documento não encontrado");
      }

      return res.json(document);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao recuperar documento" });
    }
  }
);

// Criar um novo documento
router.post(
  "",
  hasPermission(Permission.CREATE_DOCUMENT.key),
  async (req, res) => {
    try {
      const { name, description, questions, createdBy, dates} = req.body;

      // Preparar os dados do documento
      const documentData = {
        name,
        description,
        questions,
        createdBy,
        dates: {
          start: dates.start,
          teacher: dates.teacher,
          print: dates.print,
          final: dates.final,
        },
        state: "draft", // Inicialmente definido como draft
      };

      // Criar o documento no banco
      const document = await Document.create(documentData);

      if (!document) {
        throw new Error("Erro ao criar documento");
      }

      return res.json({ uuid: document.uuid });
    } catch (ex) {
      console.error("Erro ao criar documento:", ex);
      return res.status(400).json({ message: "Erro ao criar documento" });
    }
  }
);

// Atualizar um documento
router.put(
  "/:uuid",
  hasPermission(Permission.UPDATE_DOCUMENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const { name, description, questions, dates} = req.body;

      // Determinar o estado do documento com base nas condições
      let status = "draft";

      if (questions.some((q) => q.questionFileUrl)) {
        status = "in_progress";
      }

      if (
        questions.every((q) => q.questionFileUrl) &&
        questions.every((q) => q.state === "approved")
      ) {
        status = "completed";
      }

      // Preparar os dados atualizados
      const updatedData = {
        name,
        description,
        questions,
        dates: {
          start: dates.start,
          teacher: dates.teacher,
          print: dates.print,
          final: dates.final,
        },
        state: status,
      };

      // Atualizar o documento no banco de dados
      const document = await Document.findOneAndUpdate({ uuid }, updatedData, {
        new: true,
      });

      if (!document) {
        throw new Error("Erro ao atualizar documento");
      }

      return res.json({ message: "Documento atualizado com sucesso" });
    } catch (ex) {
      console.error("Erro ao atualizar documento:", ex);
      return res.status(400).json({ message: "Erro ao atualizar documento" });
    }
  }
);


// Excluir um documento
router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_DOCUMENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const document = await Document.findOneAndDelete({ uuid });

      if (!document) {
        throw new Error("Erro ao remover documento");
      }

      return res.json({ message: "Documento removido com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao remover documento" });
    }
  }
);

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/exam.route.js
const config = require("../../config");
const express = require("express");
const router = express.Router();
const { Classroom, Exam, ExamStudent, Course } = require("../../model");
const multer = require("multer");
const { doExamUpload } = require("../../util/s3.util");
const {
  Permission,
  QuestionType,
  ExamStudentStatus,
} = require("../../enumerator");
const { hasPermission, isStudent } = require("../../middleware");
const { v4: uuidv4 } = require("uuid");
const { DateTime } = require("luxon");
const { applyTimezone } = require("../../util/date.util");
const { generateArchive } = require("../../util/exam.export.util");

const upload = multer({ storage: multer.memoryStorage() });

const questionFilter = (question) =>
  [
    QuestionType.A,
    QuestionType.B,
    QuestionType.C,
    QuestionType.D,
    QuestionType.ENEM,
    QuestionType.F,
  ].includes(question.type);

const questionMapper = (question) => ({
  ...question,
  uuid: question.uuid || uuidv4(),
});

const normalizeQuestions = (questions = []) =>
  questions.filter(questionFilter).map(questionMapper);

router.get("", hasPermission(Permission.READ_EXAM.key), async (req, res) => {
  try {
    const studentsSelectFields = "-_id name email";

    const exams = await Exam.find()
      .populate([
        {
          path: "classrooms",
          select: "-_id uuid name year level",
          populate: { path: "students", select: studentsSelectFields },
        },
        {
          path: "examsInProgress",
          select: "-_id -exam uuid createdAt",
          populate: { path: "student", select: studentsSelectFields },
        },
        {
          path: "examsSubmitted",
          select: "-_id -exam uuid createdAt submittedAt",
          populate: { path: "student", select: studentsSelectFields },
        },
      ])
      .select(
        "uuid name classrooms startAt endAt durationExam examsInProgress examsSubmitted"
      )
      .lean();

    const studentMapper = (entry) => entry.student.email;

    const studentExistsFilter = (entry) => entry.student;

    const examStudentMapper = (examStudent) => {
      const { name, email } = examStudent.student;
      return { name, email };
    };

    exams.forEach((exam) => {
      const { examsInProgress, examsSubmitted, classrooms } = exam;
      let examsPending = [];
      const studentsInProgress = examsInProgress
        .filter(studentExistsFilter)
        .map(studentMapper);
      const studentsSubmitted = examsSubmitted
        .filter(studentExistsFilter)
        .map(studentMapper);
      classrooms.forEach((classroom) => {
        const studentsPending = classroom.students.filter(
          ({ email }) =>
            !studentsInProgress.includes(email) &&
            !studentsSubmitted.includes(email)
        );
        examsPending = examsPending.concat(studentsPending);
      });
      Object.assign(exam, { examsPending });
      exam.examsInProgress = exam.examsInProgress
        .filter(studentExistsFilter)
        .map(examStudentMapper);
      exam.examsSubmitted = exam.examsSubmitted
        .filter(studentExistsFilter)
        .map(examStudentMapper);
    });

    return res.json(exams);
  } catch (ex) {
    const { message = "Erro ao recuperar provas" } = ex;
    return res.status(400).json({ message });
  }
});

router.get("/available", isStudent, async (req, res) => {
  try {
    const { user: student } = req;

    const examsInProgress = await ExamStudent.find({
      student,
      status: ExamStudentStatus.PROGRESS,
    })
      .populate("exam")
      .lean();

    const examsSubmitted = await ExamStudent.find({
      student,
      status: ExamStudentStatus.SUBMITTED,
    })
      .populate("exam")
      .lean();

    const examStudentMapper = (entry) => {
      const { exam } = entry;
      const { uuid, name, startAt, endAt, durationExam } = exam;
      return {
        uuid,
        name,
        durationExam,
        startAt: applyTimezone(startAt),
        endAt: applyTimezone(endAt),
      };
    };

    const progress = examsInProgress.map(examStudentMapper);

    const done = examsSubmitted.map(examStudentMapper);

    const unavailableUuids = [...progress, ...done].map((entry) => entry.uuid);

    const classrooms = await Classroom.find({
      enabled: true,
      students: { $in: [student] },
    })
      .select("_id")
      .lean();

    const currentDateTime = DateTime.local();

    const availableExams = await Exam.find({
      classrooms: { $in: classrooms },
      uuid: { $nin: unavailableUuids },
      $or: [
        { startAt: null },
        {
          startAt: { $lte: currentDateTime },
          $or: [{ endAt: null }, { endAt: { $gte: currentDateTime } }],
        },
      ],
    }).lean();

    const comingSoonExams = await Exam.find({
      classrooms: { $in: classrooms },
      uuid: { $nin: unavailableUuids },
      startAt: {
        $gte: currentDateTime,
        $lte: currentDateTime.plus({ days: config.exam.comingSoonMaxDays }),
      },
    });

    const exampMapper = (entry) => {
      const { uuid, name, startAt, endAt, durationExam } = entry;
      return {
        uuid,
        name,
        durationExam,
        startAt: applyTimezone(startAt),
        endAt: applyTimezone(endAt),
      };
    };

    const available = availableExams.map(exampMapper);

    const comingSoon = comingSoonExams.map(exampMapper);

    return res.json({
      done,
      available,
      progress,
      comingSoon,
    });
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar provas" });
  }
});

router.get(
  "/:uuid",
  hasPermission(Permission.UPDATE_EXAM.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const exam = await Exam.findOne({ uuid })
        .populate([
          { path: "classrooms", select: "-_id uuid name" },
          {
            path: "examsInProgress",
            select: "-_id -exam uuid createdAt",
            populate: { path: "student", select: "-_id email" },
          },
          {
            path: "examsSubmitted",
            select: "-_id -exam uuid createdAt submittedAt",
            populate: { path: "student", select: "-_id email" },
          },
        ])
        .select(
          "uuid name startAt endAt durationExam instructions documentUrl questions gradeStrategy gradeOptions"
        )
        .lean();

      const courseUuids = exam.questions.reduce((acc, { course }) => {
        if (!acc.includes(course)) {
          acc.push(course);
        }
        return acc;
      }, []);

      const courses = await Course.find({ uuid: { $in: courseUuids } })
        .select("-_id uuid name")
        .lean();

      const coursesMap = courses.reduce(
        (acc, { uuid, name }) => ({
          ...acc,
          [uuid]: name,
        }),
        {}
      );

      exam.questions.forEach((question, index) => {
        Object.assign(question, {
          id: index + 1,
          course: {
            uuid: question.course,
            name: coursesMap[question.course],
          },
        });
      });

      return res.json(exam);
    } catch (ex) {
      const { message = "Erro ao recuperar prova" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.get(
  "/:uuid/export",
  hasPermission(Permission.EXPORT_EXAM.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const exam = await Exam.findOne({ uuid });

      if (!exam) {
        throw new Error("Não foi possível encontrar a prova");
      }

      const archive = await generateArchive(exam);

      archive.pipe(res);
      archive.finalize();
    } catch (ex) {
      const { message = "Erro ao recuperar prova" } = ex;
      return res.status(400).json({ message });
    }
  }
);

//// TRECHO ALTERADO PARA INCLUIR A gradeStrategy na definição de prova

router.post("", hasPermission(Permission.CREATE_EXAM.key), async (req, res) => {
  try {
    const { questions, classrooms: classroomUuids, gradeStrategy } = req.body;

    const classrooms = await Classroom.find({
      uuid: classroomUuids,
    }).select("uuid");

    const exam = await Exam.create({
      ...req.body,
      gradeStrategy,
      questions: normalizeQuestions(questions),
      classrooms,
    });

    if (!exam) {
      throw new Error("Não foi possível encontrar a prova");
    }

    const { uuid } = exam;
    return res.json({ uuid });
  } catch (ex) {
    const { message = "Erro ao criar prova" } = ex;
    return res.status(400).json({ message });
  }
});

router.put("/:uuid", hasPermission(Permission.UPDATE_EXAM.key), async (req, res) => {
  try {
    const { uuid } = req.params;
    const { questions, classrooms: classroomUuids, gradeStrategy } = req.body;

    const classrooms = await Classroom.find({
      uuid: classroomUuids,
    }).select("uuid");

    const updateQuery = {
      ...req.body,
      gradeStrategy,
      questions: normalizeQuestions(questions),
      classrooms,
    };

    const exam = await Exam.findOneAndUpdate({ uuid }, updateQuery);

    if (!exam) {
      throw new Error("Não foi possível encontrar a prova");
    }

    return res.json({ message: "Prova atualizada com sucesso" });
  } catch (ex) {
    const { message = "Erro ao atualizar prova" } = ex;
    return res.status(400).json({ message });
  }
});


//// FIM DA ALTERAÇÃO

router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_EXAM.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const exam = await Exam.findOneAndDelete({ uuid });

      if (!exam) {
        throw new Error("Não foi possível encontrar a prova");
      }

      return res.json({ message: "Prova removida com sucesso" });
    } catch (ex) {
      const { message = "Erro ao remover prova" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.post(
  "/upload",
  upload.single("file"),
  hasPermission(Permission.CREATE_EXAM.key),
  async (req, res) => {
    try {
      doExamUpload(req, res);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao enviar arquivo" });
    }
  }
);

router.post(
  "/import-questions",
  upload.single("file"),
  hasPermission(Permission.CREATE_EXAM.key),
  async (req, res) => {
    const errors = [];

    try {
      const { file } = req;

      const csvContent = file.buffer.toString("utf8").trim();
      const csvRows = csvContent.split("\n");

      const entries = [];
      const courseNames = new Set();

      for (csvRow of csvRows) {
        const [label, type, answer, course] = csvRow.trim().split(",");
        if (course) {
          courseNames.add(course);
        }
        entries.push({ uuid: uuidv4(), label, type, answer, course });
      }

      const courses = await Course.find({
        name: { $in: Array.from(courseNames) },
      })
        .select("-_id uuid name")
        .lean();

      const coursesMap = courses.reduce(
        (acc, next) => ({ ...acc, ...{ [next.name]: next.uuid } }),
        {}
      );

      entries.forEach((entry, index) => {
        const { course } = entry;
        if (course) {
          const uuid = coursesMap[course];

          if (!uuid) {
            errors.push({ index, message: "Curso não encontrado" });
          }

          Object.assign(entry, {
            course: {
              uuid,
              name: course,
            },
          });
        }
      });

      if (errors.length) {
        throw new Error("Erro ao importar questoes");
      }

      return res.status(200).send(entries);
    } catch (ex) {
      const { message } = ex;
      return res.status(400).json({ message, errors });
    }
  }
);

router.get("/:uuid/take", isStudent, async (req, res) => {
  try {
    const { user: student } = req;
    const { uuid } = req.params;

    const classrooms = await Classroom.find({
      enabled: true,
      students: { $in: [student] },
    })
      .select("_id")
      .lean();

    const exam = await Exam.findOne({
      uuid,
      classrooms: { $in: classrooms },
      enabled: true,
    });

    if (!exam) {
      throw new Error(
        "Prova inexistente, excluída ou não associada a uma turma a qual o aluno pertence"
      );
    }

    const redirect = ({ uuid }) => {
      return res.redirect(`/exam-students/${uuid}`);
    };

    if (
      await ExamStudent.exists({
        exam,
        student,
        status: ExamStudentStatus.SUBMITTED,
      })
    ) {
      throw new Error("Aluno não pode realizar a mesma prova duas vezes");
    }

    let examStudent = await ExamStudent.findOne({
      exam,
      student,
      status: ExamStudentStatus.PROGRESS,
    });

    if (examStudent) {
      return redirect(examStudent); // prova em andamento
    }

    const currentDateTime = Date.now();

    if (exam.startAt && exam.startAt > currentDateTime) {
      throw new Error(
        "Não é permitido iniciar a prova antes da data de ínicio"
      );
    }

    if (exam.endAt && exam.endAt < currentDateTime) {
      throw new Error(
        "Não é permitido iniciar a prova depois da data de término"
      );
    }

    const answers = exam.questions.reduce((acc, next) => {
      acc[next.uuid] = {
        value: "",
        skipped: false,
      };
      return acc;
    }, {});

    examStudent = await ExamStudent.create({ exam, student, answers });

    redirect(examStudent);
  } catch (ex) {
    const { message = "Erro ao iniciar prova" } = ex;
    return res.status(400).json({ message });
  }
});

router.get("/:uuid/receipt", isStudent, async (req, res) => {
  try {
    const { user: student } = req;
    const { uuid } = req.params;

    const exam = await Exam.findOne({ uuid, enabled: true }).select("id");

    if (!exam) {
      throw new Error("Prova não encontrada");
    }

    const examStudent = await ExamStudent.findOne({
      exam,
      student,
      enabled: true,
    }).select("-_id uuid");

    if (!examStudent) {
      throw new Error("Prova do aluno não encontrada");
    }

    return res.redirect(`/exam-students/${examStudent.uuid}/receipt`);
  } catch (ex) {
    const { message = "Erro ao recuperar comprovante" } = ex;
    return res.status(400).json({ message });
  }
});

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/exam.student.route.js
const express = require("express");
const multer = require("multer");
const router = express.Router();
const { ExamStudent, Course } = require("../../model");
const { isStudent } = require("../../middleware");
const { ExamStudentStatus } = require("../../enumerator");
const { doStudentUpload } = require("../../util/s3.util");
const { isQuestionAnswerValid } = require("../../util/question.util");
const { applyTimezone } = require("../../util/date.util");
const { scheduleGrade } = require("../../util/grade.util");

const upload = multer({ storage: multer.memoryStorage() });

router.get("/:uuid", isStudent, async (req, res) => {
  try {
    const { user: student } = req;
    const { uuid } = req.params;

    const examStudent = await ExamStudent.findOne({
      uuid,
      student,
      status: ExamStudentStatus.PROGRESS,
    })
      .populate("exam")
      .lean();

    if (!examStudent) {
      throw new Error();
    }

    const { answers = {}, exam, createdAt } = examStudent;
    const { questions: examQuestions, documentUrl, durationExam, name } = exam;

    const questions = examQuestions.map((question) => {
      const { type, label, uuid } = question;
      const answer = answers[uuid] || { value: "", skipped: false };
      return { type, label, uuid, answer };
    });

    return res.json({
      questions,
      documentUrl,
      name,
      uuid,
      durationExam,
      createdAt: +createdAt,
      currentTimeStamp: Date.now(),
    });
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar prova" });
  }
});

router.get("/:uuid/receipt", isStudent, async (req, res) => {
  try {
    const { user: student } = req;
    const { uuid } = req.params;

    const examStudent = await ExamStudent.findOne({
      uuid,
      student,
      status: ExamStudentStatus.SUBMITTED,
    })
      .populate("exam")
      .lean();

    const courses = await Course.find().lean();

    if (!examStudent) {
      throw new Error();
    }

    const { answers, exam, grade, createdAt, submittedAt } = examStudent;
    const { questions: examQuestions, documentUrl, name } = exam;

    const questions = examQuestions
      .filter(({ uuid }) => answers[uuid])
      .map((question) => {
        const { type, label, course, uuid } = question;
        const answer = answers[uuid];
        const { value: studentAnswer, grade } = answer;
        return {
          type,
          label,
          grade,
          studentAnswer,
          course: course
            ? courses.find(({ uuid }) => uuid === course).name
            : "",
        };
      });

    return res.json({
      questions,
      documentUrl,
      name,
      grade,
      createdAt: applyTimezone(createdAt),
      submittedAt: applyTimezone(submittedAt),
    });
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar comprovante" });
  }
});

router.post("/:uuid/submit", isStudent, async (req, res) => {
  try {
    const { user: student } = req;
    const { uuid } = req.params;
    const { answers } = req.body;

    const examStudent = await ExamStudent.findOne({
      student,
      uuid,
      status: ExamStudentStatus.PROGRESS,
    }).populate("exam");

    const {
      exam: { questions },
    } = examStudent;

    if (!examStudent) {
      throw new Error("Prova do aluno não encontrada");
    }

    const latestAnswers = { ...examStudent.answers, ...answers };

    Object.entries(latestAnswers).forEach(([questionUuid, answer]) => {
      const question = questions.find((next) => next.uuid === questionUuid);
      if (!isQuestionAnswerValid(answer, question, false)) {
        throw new Error("Resposta invalida");
      }
    });

    Object.assign(examStudent, {
      answers: latestAnswers,
      submittedAt: Date.now(),
      status: ExamStudentStatus.SUBMITTED,
    });

    await examStudent.save();

    scheduleGrade(examStudent.exam);

    return res.sendStatus(204);
  } catch (ex) {
    const { message = "Erro ao enviar prova" } = ex;
    return res.status(400).json({ message });
  }
});

router.post(
  "/:uuid/upload",
  upload.single("file"),
  isStudent,
  async (req, res) => {
    try {
      const { user: student } = req;
      const { uuid } = req.params;

      const examStudent = await ExamStudent.findOne({
        student,
        uuid,
        status: ExamStudentStatus.PROGRESS,
      })
        .populate("exam")
        .lean();

      if (!examStudent) {
        throw new Error();
      }

      doStudentUpload(examStudent, req, res);
    } catch (ex) {
      const { message = "Erro ao enviar arquivo" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.put("/:uuid/answer/:answerUuid", isStudent, async (req, res) => {
  try {
    const { user: student } = req;
    const { uuid, answerUuid } = req.params;
    const { value, skipped } = req.body;

    const examStudent = await ExamStudent.findOne({
      uuid,
      student,
      status: ExamStudentStatus.PROGRESS,
    }).populate("exam");

    if (!examStudent) {
      throw new Error("Prova do aluno não encontrada");
    }

    const {
      exam: { questions },
    } = examStudent;

    const answer = {
      value: !!skipped ? "" : value || "",
      skipped: !!skipped,
    };

    const question = questions.find(({ uuid }) => uuid === answerUuid);

    if (!question) {
      throw new Error("Questão não encontrada");
    }

    if (!isQuestionAnswerValid(answer, question)) {
      throw new Error("Resposta inválida");
    }

    examStudent.answers = {
      ...examStudent.answers,
      [answerUuid]: answer,
    };

    await examStudent.save();

    return res.sendStatus(204);
  } catch (ex) {
    const { message = "Erro ao salvar resposta" } = ex;
    return res.status(400).json({ message });
  }
});

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/import.route.js
const express = require('express');
const multer = require('multer');
const { importExamAnswers } = require('../../util/import.exam.util');

const router = express.Router();
const upload = multer({ dest: 'uploads/' });

router.post('/import', upload.single('file'), async (req, res) => {
  try {
    const filePath = req.file.path;
    await importExamAnswers(filePath);
    res.status(200).json({ message: 'Respostas importadas com sucesso' });
  } catch (error) {
    res.status(500).json({ message: 'Erro ao importar respostas', error: error.message });
  }
});

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/role.route.js
const express = require("express");
const router = express.Router();
const { Role, User } = require("../../model");
const { Permission } = require("../../enumerator");
const { hasPermission } = require("../../middleware");

router.get(
  "/permissions",
  hasPermission(Permission.READ_ROLE.key),
  async (req, res) => {
    try {
      return res.json(Permission);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao recuperar funções" });
    }
  }
);

router.get("", hasPermission(Permission.READ_ROLE.key), async (req, res) => {
  try {
    const missingPermissions = req.user.getMissingPermissions();
    const roles = await Role.find({
      permissions: { $nin: missingPermissions },
      enabled: true,
    })
      .select("-_id uuid name enabled permissions")
      .sort({ name: 1 })
      .lean();
    return res.json(roles);
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar perfis" });
  }
});

router.get(
  "/:uuid",
  hasPermission(Permission.READ_ROLE.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const missingPermissions = req.user.getMissingPermissions();
      const role = await Role.findOne({
        uuid,
        funcoes: { $nin: missingPermissions },
      }).lean();
      return res.json(role);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao recuperar perfil" });
    }
  }
);

router.post("", hasPermission(Permission.CREATE_ROLE.key), async (req, res) => {
  try {
    const { name, permissions } = req.body;
    const userPermissions = req.user.getPermissions();

    if (permissions.filter((o) => !userPermissions.includes(o)).length) {
      throw new Error(
        "Não é possível atribuir um perfil que o usuário autenticado não possui"
      );
    }

    const role = await Role.create({ name, permissions });

    if (!role) {
      throw new Error("Erro ao criar perfil");
    }

    const { uuid } = role;
    return res.json({ uuid });
  } catch (ex) {
    const { message } = ex;
    return res.status(400).json({ message });
  }
});

router.put(
  "/:uuid",
  hasPermission(Permission.UPDATE_ROLE.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const missingPermissions = req.user.getMissingPermissions();
      const role = await Role.findOneAndUpdate(
        { uuid, funcoes: { $nin: missingPermissions } },
        req.body
      );

      if (!role) {
        throw new Error("Erro ao atualizar perfil");
      }
      return res.json({ message: "Perfil atualizado com sucesso" });
    } catch (ex) {
      const { message } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_ROLE.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const missingPermissions = req.user.getMissingPermissions();
      const role = await Role.findOneAndDelete({
        uuid,
        permissions: { $nin: missingPermissions },
      });
      if (!role) {
        throw new Error("Erro ao remover perfil");
      }

      const { _id } = role;

      await User.collection.updateMany(
        {},
        {
          $pull: {
            roles: {
              $in: [_id],
            },
          },
        }
      );

      return res.json({ message: "Perfil removido com sucesso" });
    } catch (ex) {
      const { message } = ex;
      return res.status(400).json({ message });
    }
  }
);

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/staff.route.js
const express = require("express");
const router = express.Router();
const { User, Role } = require("../../model");
const { Permission, UserType } = require("../../enumerator");
const { hasPermission } = require("../../middleware");
const { encryptPassword } = require("../../util/password.util");

const type = UserType.STAFF;

router.get("", hasPermission(Permission.READ_STAFF.key), async (req, res) => {
  try {
    const users = await User.find({ type, enabled: true })
      .select("-_id uuid email name contactNumber enabled")
      .populate("roles")
      .sort({ email: 1 })
      .lean();
    return res.json(users);
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar colaboradores" });
  }
});

router.get(
  "/:uuid",
  hasPermission(Permission.READ_STAFF.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const user = await User.findOne({ uuid, type })
        .select("uuid name email ")
        .populate({ path: "roles", select: "uuid name" })
        .lean();

      if (!user) {
        throw new Error("Erro ao recuperar colaborador");
      }

      user.roles = user.roles.map((x) => x.uuid);

      return res.json(user);
    } catch (ex) {
      const { message = "Erro ao recuperar colaborador" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.post(
  "",
  hasPermission(Permission.CREATE_STAFF.key),
  async (req, res) => {
    try {
      let { roles } = req.body;
      roles = await Role.find({ uuid: roles });

      const user = await User.create({
        ...req.body,
        type,
        roles,
      });

      if (!user) {
        throw new Error();
      }

      const { uuid } = user;
      return res.json({ uuid });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao criar colaborador" });
    }
  }
);

router.post(
  "/:uuid/password",
  hasPermission(Permission.UPDATE_STAFF.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const { password } = req.body;

      const encryptedPassword = await encryptPassword(password);

      const user = await User.findOneAndUpdate(
        { uuid, type },
        { password: encryptedPassword }
      );

      if (!user) {
        throw new Error("Erro ao atualizar senha");
      }

      return res.status(204).send();
    } catch (ex) {
      const { message = "Erro ao atualizar senha" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.put(
  "/:uuid",
  hasPermission(Permission.UPDATE_STAFF.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      let { roles, password } = req.body;
      roles = await Role.find({ uuid: roles });

      const updateQuery = { ...req.body, roles };

      if (password) {
        updateQuery.password = await encryptPassword(password);
      }

      const user = await User.findOneAndUpdate({ uuid, type }, updateQuery);

      if (!user) {
        throw new Error();
      }

      return res.json({ message: "Colaborador atualizado com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao atualizar colaborador" });
    }
  }
);

router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_STAFF.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const user = await User.findOneAndDelete({ uuid, type });
      if (!user) {
        throw new Error();
      }
      return res.json({ message: "Colaborador removido com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao remover colaborador" });
    }
  }
);

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/student.route.js
const express = require("express");
const router = express.Router();
const { User, Classroom, ExamStudent } = require("../../model");
const { Permission, UserType } = require("../../enumerator");
const { hasPermission } = require("../../middleware");
const {
  EmailValidator,
  batchImportStudents,
  ClassroomValidator,
} = require("../../util/import.util");
const { encryptPassword } = require("../../util/password.util");

const type = UserType.STUDENT;

router.get("", hasPermission(Permission.READ_STUDENT.key), async (req, res) => {
  try {
    const users = await User.find({ type })
      .select("uuid email name enabled")
      .populate({
        path: "classrooms",
        select: "-_id uuid name level year -students",
      })
      .sort({ email: 1 })
      .lean();
    return res.json(users);
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar alunos" });
  }
});

router.get(
  "/:uuid",
  hasPermission(Permission.READ_STUDENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const user = await User.findOne({ uuid, type })
        .select("uuid name email")
        .populate({ path: "classrooms", select: "-_id uuid name" })
        .lean();

      if (!user) {
        throw new Error();
      }

      user.classrooms = user.classrooms.map((x) => x.uuid);

      return res.json(user);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao recuperar aluno" });
    }
  }
);

router.post(
  "",
  hasPermission(Permission.CREATE_STUDENT.key),
  async (req, res) => {
    try {
      const user = await User.create({
        ...req.body,
        type,
      });

      if (!user) {
        throw new Error("Erro ao criar aluno");
      }

      const { uuid, _id } = user;

      const { classrooms = [] } = req.body;

      await Classroom.collection.updateMany(
        { uuid: { $in: classrooms } },
        {
          $addToSet: {
            students: _id,
          },
        }
      );

      return res.json({ uuid });
    } catch (ex) {
      const { message = "Erro ao criar aluno" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.post(
  "/:uuid/password",
  hasPermission(Permission.UPDATE_STUDENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const { password } = req.body;

      const encryptedPassword = await encryptPassword(password);

      const user = await User.findOneAndUpdate(
        { uuid, type },
        { password: encryptedPassword }
      );

      if (!user) {
        throw new Error("Erro ao atualizar senha");
      }

      return res.status(204).send();
    } catch (ex) {
      const { message = "Erro ao atualizar senha" } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.put(
  "/:uuid",
  hasPermission(Permission.UPDATE_STUDENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const { password } = req.body;

      let updateQuery = { ...req.body };
      if (password) {
        updateQuery.password = await encryptPassword(password);
      }

      const user = await User.findOneAndUpdate({ uuid, type }, updateQuery);

      if (!user) {
        throw new Error();
      }

      const { _id } = user;

      const { classrooms = [] } = req.body;

      await Classroom.collection.updateMany(
        { uuid: { $nin: classrooms } },
        {
          $pull: {
            students: {
              $in: [_id],
            },
          },
        }
      );

      await Classroom.collection.updateMany(
        { uuid: { $in: classrooms } },
        {
          $addToSet: {
            students: _id,
          },
        }
      );

      return res.json({ message: "Aluno atualizado com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao atualizar aluno" });
    }
  }
);

router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_STUDENT.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const user = await User.findOneAndDelete({ uuid, type });

      if (!user) {
        throw new Error("Erro ao remover aluno");
      }

      const { _id } = user;

      await Classroom.collection.updateMany(
        {},
        {
          $pull: {
            students: _id,
          },
        }
      );

      await ExamStudent.collection.deleteMany({ student: _id });

      return res.json({ message: "Aluno removido com sucesso" });
    } catch (ex) {
      const { message } = ex;
      return res.status(400).json({ message });
    }
  }
);

router.post(
  "/import",
  hasPermission(Permission.CREATE_STUDENT),
  async (req, res) => {
    try {
      const entries = req.body;

      let errors = [];

      const emailValidator = new EmailValidator();
      const classroomValidator = new ClassroomValidator();

      entries.forEach((entry, index) => {
        emailValidator.validate(entry, index);
        classroomValidator.validate(entry, index);
      });

      await emailValidator.validateDatabase();
      await classroomValidator.validateDatabase();

      errors = errors.concat(emailValidator.getErrors());
      errors = errors.concat(classroomValidator.getErrors());

      if (errors.length) {
        errors.sort((a, b) => a.index - b.index);
        return res.status(400).json(errors);
      }

      const classroomCache = classroomValidator.getCache();

      await batchImportStudents(entries, classroomCache);

      return res.sendStatus(204);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao importar alunos" });
    }
  }
);

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected/teacher.route.js
const express = require("express");
const router = express.Router();
const { User, Classroom } = require("../../model");
const { Permission, UserType } = require("../../enumerator");
const { hasPermission } = require("../../middleware");
const { encryptPassword } = require("../../util/password.util");

const type = UserType.TEACHER;

// Listar todos os professores
router.get("", hasPermission(Permission.READ_TEACHER.key), async (req, res) => {
  try {
    const teachers = await User.find({ type, enabled: true })
      .select("uuid email name contactNumber enabled")
      .sort({ email: 1 })
      .lean();
    return res.json(teachers);
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao recuperar professores" });
  }
});

// Obter um professor específico
router.get(
  "/:uuid",
  hasPermission(Permission.READ_TEACHER.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const teacher = await User.findOne({ uuid, type })
        .select("uuid name email contactNumber enabled")
        .lean();

      if (!teacher) {
        throw new Error("Professor não encontrado");
      }

      return res.json(teacher);
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao recuperar professor" });
    }
  }
);

// Criar professor
router.post("", hasPermission(Permission.CREATE_TEACHER.key), async (req, res) => {
  try {
    const { name, email, password } = req.body;
    if (!name || !email || !password) {
      return res.status(400).json({ message: "Todos os campos obrigatórios devem ser preenchidos" });
    }    
    
    const teacher = await User.create({
      ...req.body,
      type,
    });

    if (!teacher) {
      throw new Error("Erro ao criar professor");
    }

    return res.json({ uuid: teacher.uuid });
  } catch (ex) {
    return res.status(400).json({ message: "Erro ao criar professor" });
  }
});

// Atualizar dados do professor
router.put(
  "/:uuid",
  hasPermission(Permission.UPDATE_TEACHER.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const updateQuery = { ...req.body };
      if (req.body.password) {
        updateQuery.password = await encryptPassword(req.body.password);
      }

      const teacher = await User.findOneAndUpdate({ uuid, type }, updateQuery, {
        new: true,
      });

      if (!teacher) {
        throw new Error("Erro ao atualizar professor");
      }

      return res.json({ message: "Professor atualizado com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao atualizar professor" });
    }
  }
);

// Atualizar senha do professor
router.post(
  "/:uuid/password",
  hasPermission(Permission.UPDATE_TEACHER.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;
      const { password } = req.body;

      if (!password || password.length < 6) {
        throw new Error("A senha deve ter pelo menos 6 caracteres");
      }

      const encryptedPassword = await encryptPassword(password);

      const teacher = await User.findOneAndUpdate(
        { uuid, type },
        { password: encryptedPassword }
      );

      if (!teacher) {
        throw new Error("Erro ao atualizar senha do professor");
      }

      return res.status(204).send();
    } catch (ex) {
      return res.status(400).json({ message: ex.message || "Erro ao atualizar senha" });
    }
  }
);

// Remover professor
router.delete(
  "/:uuid",
  hasPermission(Permission.DELETE_TEACHER.key),
  async (req, res) => {
    try {
      const { uuid } = req.params;

      const teacher = await User.findOneAndDelete({ uuid, type });

      if (!teacher) {
        throw new Error("Erro ao remover professor");
      }

      return res.json({ message: "Professor removido com sucesso" });
    } catch (ex) {
      return res.status(400).json({ message: "Erro ao remover professor" });
    }
  }
);

module.exports = router;




>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/protected.route.js
const express = require('express');
const router = express.Router();

router.use('/exams', require('./protected/exam.route'));
router.use('/classrooms', require('./protected/classrooms.route'));
router.use('/roles', require('./protected/role.route'));
router.use('/staff', require('./protected/staff.route'));
router.use('/courses', require('./protected/course.route'));
router.use('/account', require('./protected/account.route'));
router.use('/students', require('./protected/student.route'));
router.use('/exam-students', require('./protected/exam.student.route'));
router.use('/import', require('./protected/import.route'));
router.use('/teacher', require('./protected/teacher.route'));
router.use('/document', require('./protected/document.route'));

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/public/auth.route.js
const express = require("express");
const passport = require("passport");
const router = express.Router();

router.post("/login", async (req, res, next) => {
  console.log('Login route called with body:', req.body);
  passport.authenticate("login", { session: false }, (err, user, info) => {
    if (err) {
      console.error('Error during authentication:', err);
      return res.status(500).json({ message: "Erro de autenticação" });
    }
    if (!user) {
      console.warn('Authentication failed, user not found.');
      return res.status(401).json({ message: "Erro de autenticação" });
    }
    const token = user.getJwtToken();
    console.log('Authentication successful, token generated:', token);
    return res.json({ token });
  })(req, res, next);
});

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/public/general.route.js
const express = require("express");
const router = express.Router();
const packageJson = require("../../package.json");

router.get("/status", (req, res) => {
  return res.json({ name: packageJson.name, version: packageJson.version });
});

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/route/public.route.js
const express = require("express");
const router = express.Router();

router.use(require("./public/auth.route"));
router.use(require("./public/general.route"));

module.exports = router;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/tests/document.route.test.js
/// fail

const request = require("supertest");

const BASE_URL = "http://localhost:4000"; // URL da sua API no Docker

describe("Document Routes", () => {
  let token;
  let createdDocumentUUID;

  // Antes de todos os testes, faça login e obtenha o token
  beforeAll(async () => {
    const loginResponse = await request(BASE_URL)
      .post("/login")
      .send({
        email: "silvagirao@gmail.com", // Substitua pelo email válido
        password: "fJx5A4HFq6Y9NmcNgneT", // Substitua pela senha válida
      });

    token = loginResponse.body.token;
    expect(token).toBeDefined(); // Certifique-se de que o token foi gerado
  });

  test("Deve listar todos os documentos", async () => {
    const response = await request(BASE_URL)
      .get("/document")
      .set("Authorization", `Bearer ${token}`);

    expect(response.status).toBe(200); // Verifica se o status é 200
    expect(Array.isArray(response.body)).toBe(true); // Verifica se o corpo da resposta é um array
  });

  test("Deve criar um novo documento", async () => {
    const response = await request(BASE_URL)
      .post("/document")
      .set("Authorization", `Bearer ${token}`)
      .send({
        name: "Documento Teste",
        description: "Descrição do documento de teste",
        createdBy: "6787ec4ff6b002c32a769605",
        dates: {
          start: "2025-01-01T00:00:00Z",
          teacher: "2025-01-02T00:00:00Z",
          deadline: "2025-01-03T00:00:00Z",
          print: "2025-01-04T00:00:00Z",
          final: "2025-01-05T00:00:00Z",
        },
        intervals: {
          teacherDays: 2,
          reviewDays: 1,
          printDays: 1,
          finalDays: 1,
        },
      });

    expect(response.status).toBe(200); // Verifica se o status é 200
    expect(response.body.uuid).toBeDefined(); // Verifica se o UUID foi retornado

    createdDocumentUUID = response.body.uuid; // Salva o UUID para os próximos testes
  });

  test("Deve obter detalhes de um documento específico", async () => {
    const response = await request(BASE_URL)
      .get(`/document/${createdDocumentUUID}`)
      .set("Authorization", `Bearer ${token}`);

    expect(response.status).toBe(200); // Verifica se o status é 200
    expect(response.body.uuid).toBe(createdDocumentUUID); // Verifica se o UUID corresponde
  });

  test("Deve atualizar um documento", async () => {
    const response = await request(BASE_URL)
      .put(`/document/${createdDocumentUUID}`)
      .set("Authorization", `Bearer ${token}`)
      .send({
        name: "Documento Atualizado",
        description: "Descrição atualizada do documento de teste",
      });

    expect(response.status).toBe(200); // Verifica se o status é 200
    expect(response.body.message).toBe("Documento atualizado com sucesso"); // Verifica a mensagem de sucesso
  });

  test("Deve excluir um documento", async () => {
    const response = await request(BASE_URL)
      .delete(`/document/${createdDocumentUUID}`)
      .set("Authorization", `Bearer ${token}`);

    expect(response.status).toBe(200); // Verifica se o status é 200
    expect(response.body.message).toBe("Documento removido com sucesso"); // Verifica a mensagem de sucesso
  });

    expect(response.status).toBe(400); // Verifica se o status é 400 (Bad Request)
    expect(response.body.message).toBe("Todos os campos obrigatórios devem ser preenchidos");
  });

  test("Não deve atualizar um documento com UUID inválido", async () => {
    const response = await request(BASE_URL)
      .put("/document/uuid-invalido")
      .set("Authorization", `Bearer ${token}`)
      .send({
        name: "Documento Inválido",
      });

    expect(response.status).toBe(400); // Verifica se o status é 400 (Bad Request)
    expect(response.body.message).toBe("Erro ao atualizar documento");
  });

  test("Não deve excluir um documento com UUID inexistente", async () => {
    const response = await request(BASE_URL)
      .delete("/document/uuid-inexistente")
      .set("Authorization", `Bearer ${token}`);

    expect(response.status).toBe(400); // Verifica se o status é 400 (Bad Request)
    expect(response.body.message).toBe("Erro ao remover documento");
  });
});




>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/date.util.js
const config = require("../config");
const { DateTime } = require("luxon");

const applyTimezone = (date) =>
  DateTime.fromJSDate(date)
    .setZone(config.timezone)
    .toISO({ includeOffset: false });

module.exports = { applyTimezone };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/exam.export.util.js
const { ExamStudentStatus, QuestionType } = require("../enumerator");
const { ExamStudent } = require("../model");
const json2csv = require("json2csv");
const DateTimeFormatter = require("date-time-format-timezone");
const config = require("../config");
const archiver = require("archiver");
const { getObject } = require("./s3.util");

const dateFormatter = new DateTimeFormatter("pt-BR", {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  minute: "2-digit",
  timeZone: config.timezone,
});

function freeTextAggregrator(acc, next) {
  const { name, email, value } = next;
  return (acc += `nome: ${name}\nemail: ${email}\nresposta: ${value}\n--------------------\n`);
}

const generateCSV = async ({ exam, examStudents, questionMap, archive }) => {
  const fields = ["name", "email", "createdAt", "submittedAt"];

  Object.values(questionMap).forEach(({ index }) => {
    fields.push(`question-${index}`);
  });

  const data = examStudents.reduce((acc, next) => {
    const { student, createdAt, submittedAt, answers } = next;
    const { name, email } = student;

    const entry = {
      name,
      email,
      createdAt: dateFormatter.format(createdAt),
      submittedAt: dateFormatter.format(submittedAt),
    };

    Object.entries(answers).forEach(([key, { value }]) => {
      const question = questionMap[key];
      if (question) {
        Object.assign(entry, { [`question-${question.index}`]: value || "NP" });
      }
    });

    acc.push(entry);

    return acc;
  }, []);

  const csv = json2csv.parse(data, { fields });

  archive.append(csv, { name: `${exam.name}.csv` });
};

const generateFreeTextFolder = ({ examStudents, questionMap, archive }) => {
  const data = Object.entries(questionMap).reduce(
    (acc, [uuid, { label, type }]) => {
      if (type === QuestionType.D) {
        acc[uuid] = { label, entries: [] };
      }
      return acc;
    },
    {}
  );

  examStudents.forEach(({ answers, student }) => {
    Object.entries(answers).forEach(([uuid, { value }]) => {
      const question = data[uuid];
      if (!question) {
        return;
      }
      const { name, email } = student;
      question.entries.push({ value, name, email });
    });
  });

  Object.values(data).forEach(({ label, entries }) => {
    const output = entries.reduce(freeTextAggregrator, "");
    archive.append(output, { name: `${label}.txt`, prefix: "texto-livre" });
  });
};

const generateImagesFolder = async ({ examStudents, questionMap, archive }) => {
  const data = Object.entries(questionMap).reduce(
    (acc, [uuid, { label, type }]) => {
      if (type === QuestionType.F) {
        acc[uuid] = label;
      }
      return acc;
    },
    {}
  );

  const pendingFiles = [];

  examStudents.forEach(({ answers, student }) => {
    Object.entries(answers)
      .filter(([_, { value }]) => !!value)
      .forEach(([uuid, { value }]) => {
        const label = data[uuid];
        if (!label) {
          return;
        }
        const { email } = student;
        pendingFiles.push({ url: value, email, label });
      });
  });

  while (pendingFiles.length) {
    const currentFile = pendingFiles.pop();
    const { url, email, label } = currentFile;
    const { stream, extension } = await getObject(url);

    archive.append(stream, {
      name: `${email}.${extension}`,
      prefix: `arquivos/${label}`,
    });
  }
};

const generateArchive = async (exam) => {
  const archive = archiver("zip", { zlib: { level: 9 } });

  const examStudents = await ExamStudent.find({
    exam,
    status: ExamStudentStatus.SUBMITTED,
  }).populate("student");

  const questionMap = exam.questions.reduce(
    (acc, { uuid, label, type }, index) => {
      acc[uuid] = { index: index + 1, type, label };
      return acc;
    },
    {}
  );

  const input = { exam, examStudents, questionMap, archive };

  await generateCSV(input);

  await generateFreeTextFolder(input);

  await generateImagesFolder(input);

  return archive;
};

module.exports = { generateArchive };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/grade.util.js
const { GradeType, ExamStudentStatus } = require("../enumerator");
const { ExamStudent } = require("../model");

const strategies = {
  [GradeType.SCORE]: require("./strategy/score.strategy"),
  [GradeType.PAS]: require("./strategy/pas.strategy"),
};

const calculateScore = (examStudents, exam, type) => {
  const strategy = new strategies[type](exam.gradeOptions);
  return strategy.execute(examStudents, exam);
};

const gradeTimers = {};

const scheduleGrade = (exam) => {
  const { uuid } = exam;

  if (gradeTimers[uuid]) {
    clearTimeout(gradeTimers[uuid]);
  }

  gradeTimers[uuid] = setTimeout(async () => {
    const { gradeStrategy } = exam;

    const examStudents = await ExamStudent.find({
      exam,
      status: ExamStudentStatus.SUBMITTED,
    });

    calculateScore(examStudents, exam, gradeStrategy);

    await Promise.all(examStudents.map((examStudent) => examStudent.save()));

    delete gradeTimers[uuid];
  }, 1000 * 30);
};

module.exports = { calculateScore, scheduleGrade };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/grade.util.test.js
const fs = require("fs");
const { GradeType } = require("../enumerator");

const fileToExam = (file) => {
  const input = fs.readFileSync(file, "utf-8");
  const lines = input.split("\n");
  const exam = { questions: [] };
  lines.forEach((line) => {
    const [uuid, type, answer] = line.split(",");
    exam.questions.push({ uuid, type, answer });
  });
  return exam;
};

const fileToExamStudents = (file) => {
  const input = fs.readFileSync(file, "utf-8");
  const lines = input.split("\n");
  const examStudents = [];
  lines.forEach((line) => {
    const examStudent = { answers: {} };
    const answers = line.split(",");
    answers.forEach((answer, index) => {
      examStudent.answers[`Questao ${index + 1}`] = { value: answer };
    });
    examStudents.push(examStudent);
  });
  return examStudents;
};

const exam = fileToExam("test/eucorrijo_configuracao_1_prova_1.csv");

let examStudents = fileToExamStudents(
  "test/eucorrijo_configuracao_1_alunos.csv"
);

const calculateScore = require("./grade.util").calculateScore;

const gradeType = GradeType.PAS;

calculateScore(examStudents, exam, gradeType, {
  minGrade: 0.2,
  maxGrade: 2,
  decimalPlaces: 3,
});

let outputAsString = examStudents.reduce((acc, { answers, grade }, index) => {
  const { rawScore, factorX = 0, linearization } = grade;
  acc += `Aluno ${index + 1},${rawScore},${factorX},${linearization}\n`;
  return acc;
}, "");

fs.writeFileSync(`d:/output-${gradeType}-${Date.now()}.csv`, outputAsString);



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/import.exam.util.js
const axios = require('axios');
const fs = require('fs');

const importExamAnswers = async (filePath) => {
  const rawData = fs.readFileSync(filePath);
  const respostasPorAluno = JSON.parse(rawData);

  const baseUrl = 'http://localhost:4000/exam-students';

  for (const aluno of respostasPorAluno) {
    const { studentExamUuid, jwtToken, questions } = aluno;

    console.log(`Enviando respostas para o aluno: ${studentExamUuid}`);
    console.log(`Token JWT: ${jwtToken}`);
    console.log('Questões:', questions);

    for (const { uuid, answer, skipped } of questions) {
      try {
        const response = await axios.put(
          `${baseUrl}/${studentExamUuid}/answer/${uuid}`,
          { value: answer, skipped: skipped },
          { headers: { Authorization: `Bearer ${jwtToken}` } }
        );
        console.log(`Resposta enviada para a questão ${uuid} do aluno ${studentExamUuid}:`, response.status);
      } catch (error) {
        console.error(`Erro ao enviar resposta para a questão ${uuid} do aluno ${studentExamUuid}:`, error.response ? error.response.data : error.message);
      }
    }
  }
};

module.exports = { importExamAnswers };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/import.util.js
const { encryptPassword, generateSalt } = require("../util/password.util");
const { UserType } = require("../enumerator");
const { User, Classroom } = require("../model");
const emailValidator = require("email-validator");

const isEmptyFilter = (value) => !value;

class EntityValidator {
  cache = {};
  getCache = () => this.cache;

  errors = [];
  getErrors = () => this.errors;
  addError = (index, message) => {
    this.errors.push({ index: index + 1, message });
  };
}

class ClassroomValidator extends EntityValidator {
  validate = (entry, index) => {
    const {
      studentEmail: email,
      classroomName,
      classroomYear,
      classroomLevel,
    } = entry;

    const classroomParts = [classroomName, classroomYear, classroomLevel];

    if (classroomParts.every(isEmptyFilter)) {
      return; // turma nao foi informada
    }

    if (classroomParts.some(isEmptyFilter)) {
      this.addError(index, "Todos os campos da turma devem ser informados");
      return;
    }

    const key = classroomParts.join("|");

    if (this.cache.hasOwnProperty(key)) {
      this.cache[key].indexes.push(index);
      this.cache[key].emails.push(email);
    } else {
      this.cache[key] = { indexes: [index], emails: [email] };
    }
  };

  validateDatabase = async () => {
    await Promise.all(
      Object.keys(this.cache).map(async (key) => {
        const [name, year, level] = key.split("|");

        const classroom = await Classroom.findOne({
          name,
          year,
          level,
          enabled: true,
        });

        if (classroom) {
          this.cache[key].classroom = classroom;
        } else {
          const { indexes } = this.cache[key];

          indexes.forEach((index) => {
            this.addError(
              index,
              "A turma informada não foi cadastrada no sistema"
            );
          });
        }
      })
    );
  };
}

class EmailValidator extends EntityValidator {
  validate = (entry, index) => {
    const { studentEmail: email } = entry;

    if (!email) {
      this.addError(index, "O campo e-mail é obrigatório");
      return;
    }

    if (!emailValidator.validate(email)) {
      this.addError(index, `O email ${email} é inválido`);
      return;
    }

    if (this.cache.hasOwnProperty(email)) {
      this.addError(
        index,
        `O email ${email} já foi utilizado na linha ${this.cache[email] + 1}`
      );
      return;
    }

    this.cache[email] = index;
  };

  validateDatabase = async () => {
    const emails = Object.keys(this.cache);

    const existingEmails = await User.find({ email: { $in: emails } })
      .select("-_id email")
      .lean();

    existingEmails.forEach(({ email }) => {
      const index = this.cache[email];
      this.addError(index, `O e-mail ${email} já foi cadastrado no sistema`);
    });
  };
}

async function getEncryptedPassword(password, salt, passwordCache) {
  if (passwordCache.hasOwnProperty(password)) {
    return passwordCache[password];
  }

  const encryptedPassword = await encryptPassword(password, salt);
  passwordCache[password] = encryptedPassword;
  return encryptedPassword;
}

async function batchImportStudents(entries, classroomCache) {
  const passwordCache = {};

  const salt = await generateSalt();

  const users = await Promise.all(
    entries.map(async (entry) => {
      const {
        studentName: name,
        studentEmail: email,
        studentPassword: password = "abc123",
      } = entry;

      const encryptedPassword = await getEncryptedPassword(
        password,
        salt,
        passwordCache
      );

      return {
        name,
        email,
        password: encryptedPassword,
        type: UserType.STUDENT,
      };
    })
  );

  const persistedUsers = await User.insertMany(users);

  await Promise.all(
    Object.values(classroomCache).map(async ({ emails, classroom }) => {
      const studentsPerClassroom = persistedUsers.filter((user) =>
        emails.includes(user.email)
      );
      classroom.students = classroom.students.concat(studentsPerClassroom);
      await classroom.save();
    })
  );
}

module.exports = {
  ClassroomValidator,
  EmailValidator,
  batchImportStudents,
};



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/password.util.js
const bcrypt = require("bcrypt");

const encryptPassword = async (input, salt) => {
  if (!salt) {
    salt = await bcrypt.genSalt(1);
  }
  return await bcrypt.hash(input, salt);
};

const comparePassword = async (source, target) => {
  return await bcrypt.compare(source, target);
};

const generateSalt = async () => {
  return await bcrypt.genSalt(1);
};

module.exports = { encryptPassword, comparePassword, generateSalt };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/question.util.js
const { QuestionType } = require("../enumerator");

const isQuestionAnswerValid = (answer, question, allowEmptyAnswer = true) => {
  const { skipped, value } = answer;

  if (!question) {
    return false;
  }

  if (skipped || (allowEmptyAnswer && value === "")) {
    return true;
  }

  switch (question.type) {
    case QuestionType.A:
      return ["C", "E"].includes(value);
    case QuestionType.B: {
      return value.match(/\d{3}/);
    }
    case QuestionType.C:
      return ["A", "B", "C", "D"].includes(value);
    case QuestionType.D: {
      return !!value.length;
    }
    case QuestionType.ENEM: {
      return ["A", "B", "C", "D", "E"].includes(value);
    }
    case QuestionType.F: {
      return !!value.length;
    }
  }
};

module.exports = { isQuestionAnswerValid };



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/s3.util.js
const config = require("../config");
const AWS = require("aws-sdk");
const { v4: uuidv4 } = require("uuid");
const { StorageFolder } = require("../enumerator");

const getExtension = (contentType) => {
  return {
    "image/png": "png",
    "image/jpeg": "jpg",
    "application/pdf": "pdf",
  }[contentType];
};

const maybeAddStoragePrefix = (key) => {
  if (config.s3.prefix) {
    return `${config.s3.prefix}/${key}`;
  }
  return key;
};

const buildBaseUploadParams = (req) => {
  const file = req.file;

  if (!file) {
    throw new Error("req.file is mandatory");
  }

  const { buffer, size, mimetype } = file;

  return {
    Body: buffer,
    ACL: "public-read",
    ContentLength: size,
    ContentType: mimetype,
    Bucket: config.s3.bucket,
  };
};

const buildUploadParams = (req, prefixGenerator) => {
  const baseParams = buildBaseUploadParams(req);
  const extension = getExtension(baseParams.ContentType);
  const filename = `${uuidv4()}.${extension}`;
  const prefix = prefixGenerator();
  return {
    ...baseParams,
    Key: maybeAddStoragePrefix(`${prefix}/${filename}`),
  };
};

const getClient = () => {
  const { accessKey, secretKey } = config.s3.credentials;
  return new AWS.S3({
    accessKeyId: accessKey,
    secretAccessKey: secretKey,
  });
};

const defaultClient = getClient();

const upload = (params, res) => {
  defaultClient.upload(params, (err, data) => {
    if (err) {
      throw new Error(err);
    }
    const { Location: location } = data;
    const filename = location.substring(location.lastIndexOf("/") + 1);
    const uuid = filename.substring(0, filename.indexOf("."));
    return res.json({ uuid, location });
  });
};

const doExamUpload = (req, res) => {
  const params = buildUploadParams(req, () => {
    return `${StorageFolder.EXAMS}`;
  });
  upload(params, res);
};

const doStudentUpload = (examStudent, req, res) => {
  const { exam, uuid: examStudentUuid } = examStudent;
  const { uuid: examUuid } = exam;
  const params = buildUploadParams(req, () => {
    return `${StorageFolder.EXAMS}/${examUuid}/${examStudentUuid}`;
  });
  upload(params, res);
};

const getObject = async (url) => {
  const pathname = url.substring(url.indexOf(config.s3.bucket));
  const fileKey = pathname.substring(pathname.indexOf("/") + 1);

  const params = {
    Key: fileKey,
    Bucket: config.s3.bucket,
  };

  const data = await defaultClient.headObject(params).promise();

  const stream = await defaultClient.getObject(params).createReadStream();

  return {
    stream,
    extension: getExtension(data.ContentType),
  };
};

module.exports = {
  getObject,
  doExamUpload,
  doStudentUpload,
};



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/strategy/base.strategy.js
class BaseStrategy {
  constructor(opts) {
    this.opts = opts;
  }

  limitDecimalPlaces = (examStudents) => {
    const decimalPlaces = this.opts.decimalPlaces || 2;
    examStudents.forEach(({ answers, grade }) => {
      Object.keys(answers).forEach((key) => {
        const answer = answers[key];
        const { grade } = answer;
        if (grade) {
          Object.assign(answer, {
            grade: +parseFloat(answer.grade).toFixed(decimalPlaces),
          });
        }
      });

      Object.keys(grade).forEach((key) => {
        const value = grade[key];
        grade[key] = +parseFloat(value).toFixed(decimalPlaces);
      });
    });
  };

  calculateLinearization = (examStudents, scoreAttribute = "rawScore") => {
    const { minGrade, maxGrade, useLinearization } = this.opts;

    if (!useLinearization) {
      return;
    }

    const range = examStudents.reduce((acc, { grade }) => {
      const score = grade[scoreAttribute];
      const min = Math.min(acc.min, score);
      const max = Math.max(acc.max, score);
      return {
        min: min < score ? min : score,
        max: max > score ? max : score,
      };
    }, {});

    const { min, max } = range;

    examStudents.forEach(({ grade }) => {
      const studentScore = grade[scoreAttribute];
      const denominator = max - min || 1;
      const result =
        minGrade + ((maxGrade - minGrade) * (studentScore - min)) / denominator;
      grade.linearization = result;
    });
  };

  calculateRawScore = (examStudents, exam) => {
    examStudents.forEach((examStudent) => {
      const rawScore = this.getRawScore(examStudent, exam);
      examStudent.grade = { rawScore };
    });
  };

  getRawScore = (examStudent, exam) => {
    return Object.entries(examStudent.answers).reduce(
      (acc, [uuid, studentAnswer]) => {
        const { value } = studentAnswer;

        const question = exam.questions.filter(
          (question) => question.uuid === uuid
        )[0];

        if (question) {
          const { type, answer } = question;
          const questionValue = this.getQuestionValue(value, answer, type);
          examStudent.answers = {
            ...examStudent.answers,
            [uuid]: {
              ...studentAnswer,
              grade: questionValue,
            },
          };
          acc += questionValue;
        }

        return acc;
      },
      0
    );
  };
}

module.exports = BaseStrategy;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/strategy/pas.strategy.js
const { QuestionType } = require("../../enumerator");
const BaseStrategy = require("./base.strategy");

const questionValueByType = {
  [QuestionType.A]: {
    true: 1,
    false: -1,
  },
  [QuestionType.B]: {
    true: 2,
    false: 0,
  },
  [QuestionType.C]: {
    true: 2,
    false: -2 / 3,
  },
  [QuestionType.D]: {
    true: 0,
    false: 0,
  },
  [QuestionType.ENEM]: {
    true: 1,
    false: 0,
  },
  [QuestionType.F]: {
    true: 0,
    false: 0,
  },
};

const defaultOpts = {
  minGrade: 0,
  maxGrade: 1,
  decimalPlaces: 3,
  useLinearization: false,
};

class PasStrategy extends BaseStrategy {
  constructor(opts = {}) {
    super({ ...defaultOpts, ...opts });
  }

  execute = (examStudents, exam) => {
    this.calculateRawScore(examStudents, exam);
    this.calculateFactorX(examStudents, exam);
    this.calculateLinearization(examStudents, "factorX");
    this.limitDecimalPlaces(examStudents);
  };

  calculateFactorX = (examStudents, exam) => {
    const factorX = this.getFactorX(exam);
    examStudents.forEach(({ grade }) => {
      const { rawScore } = grade;
      grade.factorX = rawScore * factorX;
    });
  };

  getFactorX = (exam) => {
    const amountPerQuestionType = {
      [QuestionType.A]: 0,
      [QuestionType.B]: 0,
      [QuestionType.C]: 0,
      [QuestionType.D]: 0,
      [QuestionType.ENEM]: 0,
      [QuestionType.F]: 0,
    };

    exam.questions.forEach(({ type }) => {
      amountPerQuestionType[type] += 1;
    });

    return (
      exam.questions.length /
      (1 * amountPerQuestionType[QuestionType.A] +
        2 * amountPerQuestionType[QuestionType.B] +
        2 * amountPerQuestionType[QuestionType.C] +
        3 * amountPerQuestionType[QuestionType.D])
    );
  };

  getQuestionValue = (value, answer, type) => {
    return questionValueByType[type][value === answer];
  };
}

module.exports = PasStrategy;



>>> /home/silvagirao/Área de Trabalho/DEV/Aplicaprovas3/Aplicaprovas3-api/util/strategy/score.strategy.js
const BaseStrategy = require("./base.strategy");

const defaultOpts = {
  minGrade: 0,
  maxGrade: 1,
  decimalPlaces: 3,
  useLinearization: false,
};

class RawStrategy extends BaseStrategy {
  constructor(opts = {}) {
    super({ ...defaultOpts, ...opts });
  }

  execute = (examStudents, exam) => {
    this.calculateRawScore(examStudents, exam);
    this.calculateLinearization(examStudents);
    this.limitDecimalPlaces(examStudents);
  };

  getQuestionValue = (value, answer) => {
    return value === answer ? 1 : 0;
  };
}

module.exports = RawStrategy;



